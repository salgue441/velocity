name: CI Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch: # Allow manual triggering

env:
  GO_VERSION: "1.23"
  GOLANGCI_LINT_VERSION: "v1.55"

jobs:
  # Job 1: Code Quality Checks
  lint:
    name: Code Quality & Linting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Run go mod tidy
        run: |
          go mod tidy
          # Check if go.mod or go.sum changed
          if ! git diff --quiet go.mod go.sum; then
            echo "go.mod or go.sum has changes after 'go mod tidy'"
            echo "This is normal for dependency updates. Committing changes..."
            git config --global user.name 'github-actions[bot]'
            git config --global user.email 'github-actions[bot]@users.noreply.github.com'
            git add go.mod go.sum
            git commit -m "chore: update go.mod and go.sum after go mod tidy"
            # For PRs, we'll just show the diff but not fail
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "Changes detected in PR - this is informational only"
              git diff HEAD~1 go.mod go.sum || true
            fi
          else
            echo "No changes after go mod tidy"
          fi

      - name: Check code compiles
        run: go build ./...

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v8
        with:
          version: ${{ env.GOLANGCI_LINT_VERSION }}
          args: --timeout=5m --config=.golangci-minimal.yml

      - name: Run go vet
        run: go vet ./...

      - name: Check formatting
        run: |
          gofmt_output=$(gofmt -l .)
          if [ -n "$gofmt_output" ]; then
            echo "The following files are not properly formatted:"
            echo "$gofmt_output"
            exit 1
          fi

  # Job 2: Unit Tests
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ["1.22", "1.23"]
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go ${{ matrix.go-version }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.go-version }}-

      - name: Download dependencies
        run: go mod download

      - name: Run unit tests
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Generate coverage report
        if: matrix.os == 'ubuntu-latest' && matrix.go-version == '1.23'
        run: |
          go tool cover -html=coverage.out -o coverage.html
          go tool cover -func=coverage.out -o coverage.txt

      - name: Upload coverage to Codecov
        if: matrix.os == 'ubuntu-latest' && matrix.go-version == '1.23'
        uses: codecov/codecov-action@v5
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella

      - name: Upload coverage artifacts
        if: matrix.os == 'ubuntu-latest' && matrix.go-version == '1.23'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.html
            coverage.txt

  # Job 3: Integration Tests
  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [lint, test]
    services:
      # Mock backend services for integration testing
      httpbin:
        image: kennethreitz/httpbin
        ports:
          - 8080:80

      nginx:
        image: nginx:alpine
        ports:
          - 8081:80

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download dependencies
        run: go mod download

      - name: Build application
        run: |
          go build -o velocity cmd/main.go
          chmod +x velocity

      - name: Wait for services
        run: |
          timeout 30 bash -c 'until curl -f http://localhost:8080/get; do sleep 1; done'
          timeout 30 bash -c 'until curl -f http://localhost:8081; do sleep 1; done'

      - name: Run integration tests
        run: |
          # Test basic proxy functionality
          ./velocity -target=http://localhost:8080 &
          VELOCITY_PID=$!
          sleep 2

          echo "Testing health endpoint..."
          curl -f http://localhost:8080/health || exit 1

          echo "Testing proxy functionality..."
          curl -f http://localhost:8080/get || exit 1

          echo "Testing error handling..."
          curl -f http://localhost:8080/status/500 || echo "Expected failure - OK"

          kill $VELOCITY_PID
          echo "✅ Integration tests passed!"

      - name: Test configuration loading
        run: |
          # Create test configuration
          cat > test-config.yaml << EOF
          server:
            host: "127.0.0.1"
            port: 9090
          targets:
            - url: "http://localhost:8080"
              weight: 60
              enabled: true
            - url: "http://localhost:8081"
              weight: 40
              enabled: true
          load_balancing:
            algorithm: "weighted_round_robin"
          EOF

          # Test configuration validation
          go run cmd/main.go -config=test-config.yaml &
          CONFIG_PID=$!
          sleep 2

          curl -f http://localhost:9090/health || exit 1
          kill $CONFIG_PID

          rm test-config.yaml
          echo "✅ Configuration tests passed!"

  # Job 4: Security Scanning
  security:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run gosec security scanner
        uses: securecodewarrior/github-action-gosec@master
        with:
          args: "./..."

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

  # Job 5: Build and Package
  build:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: [test, integration]
    strategy:
      matrix:
        goos: [linux, windows, darwin]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-build-${{ matrix.goos }}-${{ matrix.goarch }}-${{ hashFiles('**/go.sum') }}

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          # Build with version info
          VERSION=${GITHUB_REF#refs/tags/}
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VERSION="dev-${GITHUB_SHA::8}"
          fi

          BINARY_NAME="velocity"
          if [ "$GOOS" = "windows" ]; then
            BINARY_NAME="velocity.exe"
          fi

          go build \
            -ldflags="-s -w -X main.version=$VERSION -X main.buildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ) -X main.gitCommit=${GITHUB_SHA::8}" \
            -o "dist/${BINARY_NAME}-${GOOS}-${GOARCH}" \
            cmd/main.go

      - name: Create archive
        run: |
          cd dist
          BINARY_NAME="velocity"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            BINARY_NAME="velocity.exe"
          fi

          ARCHIVE_NAME="velocity-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            zip "${ARCHIVE_NAME}.zip" "${BINARY_NAME}-${{ matrix.goos }}-${{ matrix.goarch }}"
          else
            tar -czf "${ARCHIVE_NAME}.tar.gz" "${BINARY_NAME}-${{ matrix.goos }}-${{ matrix.goarch }}"
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: velocity-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/velocity-${{ matrix.goos }}-${{ matrix.goarch }}*

  # Job 6: Docker Build
  docker:
    name: Docker Build & Test
    runs-on: ubuntu-latest
    needs: [test, integration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create Dockerfile
        run: |
          cat > Dockerfile << 'EOF'
          # Build stage
          FROM golang:1.23-alpine AS builder

          WORKDIR /app
          COPY go.mod go.sum ./
          RUN go mod download

          COPY . .
          RUN CGO_ENABLED=0 GOOS=linux go build \
              -ldflags="-s -w" \
              -o velocity cmd/main.go

          # Runtime stage
          FROM alpine:latest

          RUN apk --no-cache add ca-certificates curl
          WORKDIR /root/

          COPY --from=builder /app/velocity .

          EXPOSE 8080

          HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
            CMD curl -f http://localhost:8080/health || exit 1

          CMD ["./velocity"]
          EOF

      - name: Build Docker image
        run: |
          docker build -t velocity-gateway:test .

      - name: Test Docker image
        run: |
          # Start container
          docker run -d --name velocity-test -p 8080:8080 \
            -e VELOCITY_LOGGING_LEVEL=debug \
            velocity-gateway:test -target=https://httpbin.org

          # Wait for startup
          sleep 5

          # Test health endpoint
          curl -f http://localhost:8080/health

          # Test proxy
          curl -f http://localhost:8080/get

          # Cleanup
          docker stop velocity-test
          docker rm velocity-test

          echo "✅ Docker tests passed!"

      - name: Save Docker image
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          docker save velocity-gateway:test | gzip > velocity-gateway-docker.tar.gz

      - name: Upload Docker image artifact
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: velocity-gateway-docker
          path: velocity-gateway-docker.tar.gz

  # Job 7: Performance Testing
  performance:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: velocity-linux-amd64
          path: ./

      - name: Make binary executable
        run: chmod +x velocity-linux-amd64

      - name: Install k6
        run: |
          curl https://github.com/grafana/k6/releases/download/v0.47.0/k6-v0.47.0-linux-amd64.tar.gz -L | tar xvz
          sudo mv k6-v0.47.0-linux-amd64/k6 /usr/local/bin/

      - name: Create k6 test script
        run: |
          cat > performance-test.js << 'EOF'
          import http from 'k6/http';
          import { check, sleep } from 'k6';

          export let options = {
            stages: [
              { duration: '30s', target: 100 },
              { duration: '1m', target: 500 },
              { duration: '30s', target: 0 },
            ],
            thresholds: {
              http_req_duration: ['p(95)<100'],
              http_req_failed: ['rate<0.01'],
            },
          };

          export default function() {
            let response = http.get('http://localhost:8080/health');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 50ms': (r) => r.timings.duration < 50,
            });
            sleep(0.1);
          }
          EOF

      - name: Run performance tests
        run: |
          # Start velocity gateway
          ./velocity-linux-amd64 -target=https://httpbin.org &
          VELOCITY_PID=$!
          sleep 3

          # Run k6 performance test
          k6 run performance-test.js

          # Cleanup
          kill $VELOCITY_PID

          echo "✅ Performance tests completed!"

  # Job 8: Summary
  summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [lint, test, integration, security, build, docker]
    if: always()
    steps:
      - name: Check results
        run: |
          echo "CI Pipeline Summary:"
          echo "==================="
          echo "Lint: ${{ needs.lint.result }}"
          echo "Test: ${{ needs.test.result }}"
          echo "Integration: ${{ needs.integration.result }}"
          echo "Security: ${{ needs.security.result }}"
          echo "Build: ${{ needs.build.result }}"
          echo "Docker: ${{ needs.docker.result }}"

          # Fail if any critical job failed
          if [[ "${{ needs.lint.result }}" == "failure" || "${{ needs.test.result }}" == "failure" || "${{ needs.integration.result }}" == "failure" ]]; then
            echo "❌ Critical jobs failed"
            exit 1
          else
            echo "✅ All critical jobs passed"
          fi
